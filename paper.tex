\documentclass{article}

% Memory address
\newcommand\hex[1]{{\tt #1}}
\newcommand\hexrange[2]{\hex{#1}{\tt -}\hex{#2}}

% Document
\begin{document}

\title{Peer-to-Peer 6502 Cellular Automata}
\author{Ian Holmes \\ Berkeley, California, USA}

\maketitle


\begin{abstract}
  As a toy illustration,
  this paper describes a blockchain for cellular automata
  comprising a 3D array of virtual machines.
  Each machine emulates a 6502 processor with access to one page (256 bytes) of persistent storage,
  as well as the pages of its neighbors (and a read-only operating system).
  Simulation of this machine is incentivized via mining,
  writes are limited by transaction fee,
  and communications between adjacent nodes on the 3D grid are modeled as blockchain mergers.
\end{abstract}

\section{Cellular automata}

\subsection{Storage}
\label{sec:Storage}

The cellular automaton (CA) is a $L \times L \times L$ array of cells,
located at an offset $(\alpha_x,\alpha_y,\alpha_z)$ in integer 3-space.
Cells in the CA are indexed $(x,y,z$) where
$\alpha_x \leq x < \alpha_x+L$,
$\alpha_y \leq y < \alpha_y+L$,
$\alpha_z \leq z < \alpha_z+L$.

Each cell has 256 bytes (one page) of state.
All cells' bytes are initially zero, unless otherwise specified
(including, implicitly, cells whose coordinates are outside the CA; see also Section~\ref{sec:AdjacentCells}).
These bytes are the storage of the virtual machine.

\subsection{Virtual machine}

An {\bf update} of the CA consists of updating each cell in the CA in a pseudorandom order.
This can be any order that visits $L^3$ uniformly-random selected cells;
a Mersenne Twister is suitable for this.

A cell $(x,y,z)$ is updated by emulating an 8-bit virtual machine.
The CPU is the MOS Technology 6502 processor.
The memory map is shown in Table~\ref{tab:MemoryMap}.
In this memory map, the 27 pages of storage
for the cell and its 26 neighbors
in the $3 \times 3 \times 3$ unit cube centered on $(x,y,z)$
are mapped directly to bytes in the address range \hexrange{4000}{7FFF} of the virtual machine.

The detailed description of the memory map for this $3 \times 3 \times 3$ neighborhood,
which in cellular automata terminology is
the {\em three-dimensional Moore neighborhood},
is given in Table~\ref{tab:MooreNeighborhood}.

The neighborhood memory map can be understood as the cell $(x+i-1,y+j-1,z+k-1)$
mapping to page number (64+i*16+j*4+k) with $i,j,k \in \{0,1,2\}$.
Thus, in a memory-mapped 16-bit address, the bits have the meanings shown in Table~\ref{tab:AddressBits}.
Note the exception: cell $(x,y,z)$ is not mapped to page 85 (\hexrange{5500}{55FF})
because it is mapped to zero page (\hexrange{0000}{00FF}) instead.

At the beginning of an update,
the registers {\tt A,X,Y} are initialized to zero,
all status flags (register {\tt P}) are set to zero,
the stack pointer (register {\tt SP}) is set to \hex{FF},
the program counter {\tt PC} is set to \hex{0000},
and execution begins at the first byte of zero page.

Execution is terminated
when a software interrupt or undefined instruction is encountered,
or by non-maskable interrupt after
completion of the first instruction that takes the cycle count past 65,536 cycles.

On termination, the transient address ranges in the memory map
(including the stack)
are discarded.
The neighborhood memory map (\hexrange{4000}{7FFF}, Table~\ref{tab:MooreNeighborhood})
is copied back to the cellular automata storage.

\subsection{Adjacent cells}
\label{sec:AdjacentCells}

Consider those cell coordinates $(x,y,z)$ that are outside the CA,
e.g. $(\alpha_x-1,\alpha_y,\alpha_z)$ or  $(\alpha_x,\alpha_y,\alpha_z + L)$.
Some of these, specifically those in the Moore neighborhood of cells that are in the CA,
are a relevant initial condition for the machine,
since they map to bytes in its addressable memory.

We refer to these cells as the CA's {\bf adjacent cells}.
Earlier, in Section~\ref{sec:Storage}, we specified that the state of these cells was implicitly initialized to zero.
More generally, we may refer to the initial (and perpetual, throughout the execution of an update)
state of these cells as the CA's {\bf adjacent state}.
This adjacent state is zero until otherwise specified, but may be affected
by interactions with neighboring CAs in the infinite vector space,
as for example by the blockchain of Section~\ref{sec:Blockchain}.

\section{Blockchain}
\label{sec:Blockchain}

The CA has an associated blockchain, defined as in \cite{Nakamoto2008}.
Updates are incentivized by mining,
and the reward for mining is adjusted to include redemption of coins mined by adjacent CA blockchains
(this also updates the adjacent cell states accounted for by those CAs).

\subsection{Updates}

A valid block must include the $256 \times L^3$ bytes describing the state of the CA following $C$ updates
from the state at the end of the previous block.
$C$ is the number of cycles per cell expected in the blockchain update time
(which for bitcoin is 10 minutes).

Let the definition of a block include the coordinates $(\alpha_x,\alpha_y,\alpha_z,L)$;
these coordinates, together with the number of updates,
must be used to seed the random number generator for the $Z$ updates.

\subsection{Write operations}

Any transaction in the blockchain may include, as additional data,
a {\bf write operation} which modifies the state of one or more cells of the CA.
This modification is considered to take place after the emulation of $Z$ update cycles
which is part of the proof-of-work protocol.
The order in which such write operations are applied,
each potentially overwriting the state modifications of its predecessors,
is implied by the ordering of the transaction in the block.
As usual, the transaction may include network fees to incentivize inclusion of transactions
by the miner
(and prioritization later in the block).
The transaction fee is, as usual, the difference between the output and input values of the transaction,
minus a write operation tax of $W$ coins per cell written,
to discourage frivolous edits.
(Suggest $W=1$ to keep this simple.
Minting a coin lets you write a cell.
Seems fair.)

\subsection{Adjacent segments}

The block may include sections of blockchain from {\bf adjacent cellular automata},
defined to be CAs with co-ordinate ranges that
overlap with the current CA's adjacent cells,
but no cells that overlap with
cells in the co-ordinate range of this CA (or any other CA previously encountered in the blockchain,
except the adjacent CA itself).
These blockchain segments from adjacent CAs are called {\bf adjacent segments}.

Adjacent segments must be consistent with any previously-observed adjacent segments
earlier on the current blockchain (that is, they must not involve conflicting CA,
and they must otherwise be consistent continuations of the adjacent CA's blockchain).
They may, themselves, recursively refer to parts of the current blockchain as their own adjacent segments,
summarized by their hashes for compactness.

When a block includes an adjacent segment, the CA's adjacent cell state is updated to match the adjacent segment.
Regular mutual inclusion of adjacent segments from adjacent CAs' blockchains
corresponds to keeping a bidirectional read-only interface open between those CAs.

To incentivize this,
inclusion of an adjacent segment in a block for the first time
accrues an additional benefit of $C/R$ coins to the miner of the block,
where $C$ is the number of {\bf redeemable coins} mined or accrued (via more distant, proximal adjacencies)
by cells in the adjacent CA,
and $R$ is the {\bf redemption rate}, the number of redeemable coins in adjacent CAs
required to accrue a coin in the current CA.
It is of course necessary to have $R>2$ to prevent an explosion of redeemable coins in 3D space;
another notable value is $R=26$, which (in the densely-connected Moore neighborhood)
ensures that the number of coins redeemed is less than the number of coins mined locally
(the corresponding value for the von Neumann neighborhood of Table~\ref{tab:VonNeumannNeighborhood}
is much lower, at $R=6$).

Setting the parameters $L$ (CA size) and $C$ (updates per block)
is a little arbitrary, but can be guided by target memory footprint and clock rate.
For memory, the CA state requires $256 \times L^3$ bytes.
For clock rate, if we ran a 6502 CPU at 1Mhz for 10 minutes, with a mean of $2^{15}$ cycles per cellular update,
we would update the whole board $10^6 \times T / (2^{15} \times L^3)$ times
where $T$ is the time in seconds between blocks ($T=36,000$ for bitcoin).
Faster clocks and protocols no doubt allow better numbers,
but considering these values and estimating conservatively,
we recommend $L=64$ and $C=4$ so that
each cell is updated every few minutes;
each block takes at most 64Mb to describe the CA state;
and the computational burden is roughly comparable to a 6502 CPU.

% Tables, macros
% Macro to generate neighborhood memory map table
\newcommand\memtable[1]{
\begin{tabular}{lll}
  \hline
  From & To & Contents \\
  \hline
  #1
  \hline
\end{tabular}
}

\newcommand\memrow[4]{
    {\tt {#1}00} & {\tt {#1}FF} & State of cell $(x#2,y#3,z#4)$ \\
}

% The \memxyz macro gives a densely-connected (von Neumann) neighborhood
\newcommand\memz[5]{
  \memrow{#1}{#4}{#5}{-1}
  \memrow{#2}{#4}{#5}{}
  \memrow{#3}{#4}{#5}{+1}
}

\newcommand\memyz[2]{
  \memz{{#1}0}{{#1}1}{{#1}2}{#2}{-1}
  \memz{{#1}4}{{#1}5}{{#1}6}{#2}{}
  \memz{{#1}8}{{#1}9}{{#1}A}{#2}{+1}
}

\newcommand\memxyz{
  \memyz{4}{-1}

  %  \memyz{5}{} includes zero page-mapped cell (x,y,z), which we want to skip, so spell it out without that
  \memz{50}{51}{52}{}{-1}
  \memrow{54}{}{}{-1}
  \memrow{56}{}{}{+1}
  \memz{58}{59}{5A}{}{+1}

  \memyz{6}{+1}
}

% The following table is a sparse neighborhood
\newcommand\vonneumannmap{\memtable{
  \memrow{45}{-1}{}{}
  \memrow{51}{}{-1}{}
  \memrow{54}{}{}{-1}
  \memrow{56}{}{}{+1}
  \memrow{59}{}{+1}{}
  \memrow{65}{+1}{}{}
}}

% The following neighborhood is dense
\newcommand\mooremap{\memtable{\memxyz}}

% Tables
\begin{table}
\begin{tabular}{llll}
  \hline
  From & To & Type & Contents \\
  \hline
  \hex{0000} & \hex{00FF} & RAM (storage-mapped) & State of cell $(x,y,z)$ \\
  \hex{0100} & \hex{01FF} & RAM (transient) & Stack, initialized to zero \\
  \hex{0200} & \hex{03FF} & RAM (transient) & Scratch memory, initialized to zero \\
  \hex{0400} & \hex{3FFF} & ROM & Reserved, zero \\
  \hex{4000} & \hex{7FFF} & RAM (storage-mapped) & Memory-mapped neighborhood (Table~\ref{tab:MooreNeighborhood}) \\
  \hex{8000} & \hex{FFFF} & ROM & Operating system \\
  \hline
\end{tabular}
\caption{
  \label{tab:MemoryMap}
  Memory map for the 6502 virtual machine of cell $(x,y,z)$.
}
\end{table}

\begin{table}
\mooremap
\caption{
  \label{tab:MooreNeighborhood}
  Memory map for the 6502 virtual machine of cell $(x,y,z)$,
  using the 26-cell three-dimensional Moore neighborhood.
  All address ranges not defined in this table are read-only and zero;
  writing to these addresses has no effect.
  Pages mapping to cells outside the CA (e.g. $x<\alpha_x$ or $x \geq \alpha_x+L$, or similarly for $y,z$)
  are read-only and zero (unless otherwise specified, as in Section~\ref{sec:AdjacentCells}).
  Writing to these addresses has no effect.
}
\end{table}

\begin{table}
\vonneumannmap
\caption{
  \label{tab:VonNeumannNeighborhood}
  Memory map for the 6502 virtual machine of cell $(x,y,z)$,
  using the 6-cell three-dimensional von Neumann neighborhood.
  This memory map may be considered a subset of the memory map in Table~\ref{tab:MooreNeighborhood}.
}
\end{table}

\begin{table}
\begin{tabular}{ll}
  \hline
  Bit(s) & Meaning \\
  \hline
  14,15 & Must be \hex{01} \\
  12,13 & $i$ \\
  10,11 & $j$ \\
  8,9 & $k$ \\
  0-7 & Address within page \\
  \hline
\end{tabular}
\caption{
  Interpretation of an address in the memory-mapped range \hexrange{4000}{7FFF}
  as pointing to a cell $(x+i-1,y+j-1,z+k-1)$.
  See Table~\ref{tab:MooreNeighborhood} and Table~\ref{tab:VonNeumannNeighborhood}.
  Note that $i,j,k, \in \{ 0,1,2 \}$.
  \label{tab:AddressBits}
}
\end{table}

\section*{Acknowledgments}
Thanks to Peter Irvine, Chris Evans, Richard Evans, Michael Mateas.

\bibliographystyle{plain}
\bibliography{references}

\end{document}
